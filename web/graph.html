<!DOCTYPE html>
<html>
<body>
  <div id="container"></div>
  <div style="margin-top: 16px;">
    Drag to zoom, double-click to re-initialize.
  </div>

  <script src="https://d3js.org/d3.v6.js"></script>
  <script type="text/javascript">
    // REFERENCES:
    //   https://www.d3-graph-gallery.com/graph/line_brushZoom.html
    //   https://www.d3-graph-gallery.com/graph/line_several_group.html

// set the dimensions and margins of the graph
const margin = {top: 10, right: 30, bottom: 30, left: 60},
  width = 460 - margin.left - margin.right,
  height = 400 - margin.top - margin.bottom;

// append the svg object to the body of the page
const container = d3.select("#container");
const svg = container
  .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", `translate(${margin.left}, ${margin.top})`);
const legend = container.append("div");

//Read the data
//d3.csv("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/3_TwoNumOrdered_comma.csv",
const urlSearchParams = new URLSearchParams(window.location.search);
const csvFile = urlSearchParams.get("csv") || "/metrics.csv";
d3.csv(csvFile,

    // When reading the csv, I must format variables:
    function(d){
          //return { date : d3.timeParse("%Y-%m-%d")(d.date), value : d.value }
          return { date : +d.timestamp, name : d.name, value : +d.value }
        }).then(

            // Now I can use this dataset:
            function(data) {

              console.log(data);
              let min_date = d3.min(data, d => d.date);
              data = data.map(d => {
                d.date = d.date - min_date;
                return d;
              });
              console.log(data);

              const grouped = d3.group(data, d => d.name);
              console.log(grouped);

              // Color pallette
              const color = d3.scaleOrdinal()
                  .range(['#e41a1c','#377eb8','#4daf4a','#984ea3','#ff7f00','#ffff33','#a65628','#f781bf','#999999']);


              // Populate the legend.
              let legendEntry = legend.selectAll("div").data(grouped)
                .join("div");
              legendEntry.append("input")
                .attr("type", "checkbox")
                .attr("checked", "true")
                .attr("id", (d, i) => {
                  return "checkbox-" + i;
                })
                .on("change", redrawLines);
              legendEntry.append("span")
                .style("color", d => color(d[0]))
                .text(d => d[0]);

                  // Add X axis --> it is a date format
                  const x = d3.scaleLinear()
                    .domain(d3.extent(data, function(d) { return d.date; }))
                    .range([ 0, width ]);
                  xAxis = svg.append("g")
                    .attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(x));

                  // Add Y axis
                  const y = d3.scaleLinear()
                    .domain(d3.extent(data, function(d) { return +d.value; }))
                    //.domain([0, d3.max(data, function(d) { return +d.value; })])
                    .range([ height, 0 ]);
                  yAxis = svg.append("g")
                    .call(d3.axisLeft(y));

                  // Add a clipPath: everything out of this area won't be drawn.
                    const clip = svg.append("defs").append("svg:clipPath")
                      .attr("id", "clip")
                      .append("svg:rect")
                      .attr("width", width )
                      .attr("height", height )
                      .attr("x", 0)
                      .attr("y", 0);

                  // Add brushing
                  //const brush = d3.brushX()                   // Add the brush feature using the d3.brush function
                  const brush = d3.brush()                   // Add the brush feature using the d3.brush function
                      .extent( [ [0,0], [width,height] ] )  // initialise the brush area: start at 0,0 and finishes at width,height: it means I select the whole graph area
                      .on("end", updateChart)               // Each time the brush selection changes, trigger the 'updateChart' function

                  // Create the line variable: where both the line and the brush take place
                  const line = svg.append('g')
                    .attr("clip-path", "url(#clip)")

                  // Add the line
                  //line.append("path")
                  //  .datum(data)
                  //  .attr("class", "line")  // I add the class line to be able to modify this line later on.
                  //  .attr("fill", "none")
                  //  .attr("stroke", "steelblue")
                  //  .attr("stroke-width", 1.5)
                  //  .attr("d", d3.line()
                  //            .x(function(d) { return x(d.date) })
                  //            .y(function(d) { return y(d.value) })
                  //            )
                  line.selectAll(".line")
                    .data(grouped)
                    .join("path")
                    .attr("class", "line")  // I add the class line to be able to modify this line later on.
                    .attr("fill", "none")
                    //.attr("stroke", "steelblue")
                    .attr("stroke", d => color(d[0]))
                    .attr("stroke-width", 1.5)
                .attr("d", (d) => {
                  return d3.line()
                              .x(function(d) { return x(d.date) })
                              .y(function(d) { return y(d.value) })
                  (d[1])
                })

                  // Add the brushing
                  line
                    .append("g")
                      .attr("class", "brush")
                      .call(brush);

              function redrawLines() {
                line.selectAll('.line')
                  .transition()
                  .duration(1000)
                  .style("opacity", (d, i) => {
                    if (d3.select("#checkbox-" + i).property("checked")) {
                      return 1;
                    }
                    return 0;
                  })
                  .attr("d", (d) => {
                    return d3.line()
                        .x(function(d) { return x(d.date) })
                        .y(function(d) { return y(d.value) })
                        (d[1]);
                  });
              }

                  // A function that set idleTimeOut to null
                  let idleTimeout
                  function idled() { idleTimeout = null; }

                  // A function that update the chart for given boundaries
                  function updateChart(event,d) {
                    // What are the selected boundaries?
                    extent = event.selection;

                    // If no selection, back to initial coordinate. Otherwise, update X axis domain
                    if(!extent){
                      // This allows to wait a little bit
                      if (!idleTimeout) return idleTimeout = setTimeout(idled, 350);
                      x.domain([ 4,8])
                    }else{
                      x.domain([ x.invert(extent[0][0]), x.invert(extent[1][0]) ]);
                      y.domain([ y.invert(extent[1][1]), y.invert(extent[0][1]) ]);
                      // This remove the grey brush area as soon as the selection has been done
                      line.select(".brush").call(brush.move, null);
                    }

                    // Update axis and line position
                    xAxis.transition().duration(1000).call(d3.axisBottom(x))
                    yAxis.transition().duration(1000).call(d3.axisLeft(y))
                    line
                      .selectAll('.line')
                      .transition()
                      .duration(1000)
                      //.attr("d", d3.line()
                      //            .x(function(d) { return x(d.date) })
                      //            .y(function(d) { return y(d.value) })
                      //        )
                      .attr("d", (d) => {
                        return d3.line()
                            .x(function(d) { return x(d.date) })
                            .y(function(d) { return y(d.value) })
                            (d[1]);
                      })
                  }

                  // If user double click, reinitialize the chart
                  svg.on("dblclick",function(){
                    x.domain(d3.extent(data, function(d) { return d.date; }));
                    y.domain(d3.extent(data, function(d) { return +d.value; }));
                    xAxis.transition().call(d3.axisBottom(x));
                    yAxis.transition().call(d3.axisLeft(y));
                    line
                      .selectAll('.line')
                      .transition()
                      //.attr("d", d3.line()
                      //            .x(function(d) { return x(d.date) })
                      //            .y(function(d) { return y(d.value) })
                      //        )
                      .attr("d", (d) => {
                        return d3.line()
                            .x(function(d) { return x(d.date) })
                            .y(function(d) { return y(d.value) })
                            (d[1]);
                      })
                  });

            })
  </script>
</body>
</html>
